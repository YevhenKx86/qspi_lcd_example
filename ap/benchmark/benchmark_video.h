//#pragma once
#include <stdint.h>
//#include "hal_gpt.h"    //hal_gpt_get_free_run_count
//#include "task.h"       //TaskHandle_t
//#include "display.h" 

int display_model_idx = 9;
#define DH 240
#define DW 240

// 1-bit 8x8 letters from U+0020 (space) to U+007E (~)
const uint8_t BITFONT[128-32-1][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};


int SomeAnimationCounter = 0;
//TaskHandle_t TaskHandleBenchmarkVideo = 0;


//Draw text for debug purposes
static void draw_text(uint16_t* framebuf, const char* text, int x, int y, uint16_t color)
	{
		const int k = 1; //Single or doubled pixels
		int cx = x, cy = y;
		for (const uint8_t* c = (const uint8_t*)text;  *c != 0;  c++,  cx += k*8) 
		{
			//Newline or autowrap
			if (*c == 0x0A || cx >= DW-18) { cx = x; cy += k*10; continue; }

			//Skip special chars
			if (*c < 0x20 || *c >= 0x7F) continue;

			//Set pixels by mask
			for(int yy = 0; yy < 8;  yy+=1)
			for(int xx = 0, mf = BITFONT[(*c)-0x20][yy];  xx < 8;  xx+=1,  mf = mf >> 1)
			{				
                if (mf & 1)
				for(int ddy = 0;  ddy < k;  ddy+=1)
				for(int ddx = 0;  ddx < k;  ddx+=1)
					framebuf[(cy+k*yy+ddy) * DW + cx+k*xx+ddx] = color;
			}
		}		
	}

/*
void BenchmarkVideo(void* arg)
    {
        uint32_t time_start; 
        hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_32K, &time_start);
        uint32_t time_now = time_start; 


        int renders_num = 1;
        char fps[32];
        fps[0] = '0', fps[1] = 0; 
        while (1)
        {
            //Copy buffers to cube displays
            SomeAnimationCounter += 16;
		    for(uint8_t display_index = 0; display_index < DISPLAY_COUNT; display_index++) 
            {
                uint16_t* framebuf = (uint16_t*)(DISPLAY_getFramebuffer(display_index)->data);

                //Redraw buffer in corner
                for (int i=180; i < DH; i++) 
                    for (int j=180; j < DW; j++) 
                        framebuf[i*DW+j] = (uint16_t)((i + SomeAnimationCounter) / 4);

                //Milliseconds per frame on average
                int ms = ((time_now-time_start) / 32)  / renders_num;

                //Update text each 10 frames
                if ((renders_num % 10) == 0)
                {
                   fps[2] = '0' + (ms%10);
                   fps[1] = '0' + ((ms/10)%10);
                   fps[0] = '0' + ((ms/100)%10);
                   fps[3] = 0;
                }

                draw_text(framebuf, fps, 200, 200, 0xFFFF);

                //Run DMA
                hal_display_lcd_layer_input_t layer_params;	
                memset(&layer_params, 0, sizeof(layer_params));
                layer_params.layer_enable   = 0;
                layer_params.rotate         = HAL_DISPLAY_LCD_LAYER_ROTATE_270;
                layer_params.color_format   = HAL_DISPLAY_LCD_LAYER_COLOR_RGB565;
                layer_params.buffer_address = (uintptr_t)framebuf;
                layer_params.row_size       = DW;
                layer_params.column_size    = DH;
                layer_params.pitch          = DW * 2;
                
                DISPLAY_WaitDMA();
                DISPLAY_StartDMA(display_index, &layer_params);	
            }

            //One more render completed
            renders_num++;
            hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_32K, &time_now);
        }

        (void)arg;
    }
*/